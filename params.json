{"name":"Sequelocity.NET","tagline":"Sequelocity.NET is a simple data access library for the Microsoft .NET Framework providing lightweight ADO.NET wrapper, object mapper, and helper functions.","body":"Sequelocity.NET\r\n===============\r\n\r\n*Note that this project is currently in a pre-release state.*\r\n\r\n###What is it?###\r\n\r\nSequelocity.NET is a simple data access library for the Microsoft .NET Framework providing lightweight ADO.NET wrapper, object mapper, and helper functions.\r\n\r\nIt enables you to write fluent style syntax creating a more elegant and concise way of writing data access code. \r\n\r\nIt can be used as a C# single file drop in or referenced as a DLL and found on NuGet ( NuGet release coming soon ).\r\n\r\n###Documentation?###\r\n\r\nYes, we have documentation. =)\r\n\r\n**XML Comments**\r\n\r\nAll of the methods in the codebase our heavily XML commented which should give you plenty of intellisense description feel-goodness.\r\n\r\n**Wiki**\r\n\r\nWe have a growing number of wiki articles that can be found here: https://github.com/AmbitEnergyLabs/Sequelocity.NET/wiki\r\n\r\n**MSDN-Style Documentation**\r\n\r\nWe will also soon have MSDN-style documentation to explore.\r\n\r\n###Why Use It?###\r\n\r\nHere is the super awesome list of reasons to use Sequelocity:\r\n- Simplifies your code by eliminating repetitive boilerplate code\r\n- Offers a very readable and concise fluent ( method chaining ) syntax\r\n- Automatically handles all database connection opening, closing, and disposing of unneeded resources\r\n- Can map results back to strongly typed objects, dynamic objects, DataSets or DataTables\r\n- Can generate SQL insert statements given a strongly typed object, anonymous object, or dynamic object\r\n- Is backed by over 300 tests\r\n\r\n###Usage###\r\n\r\nOne of the design goals of Sequelocity is provide a very simple fluent ( method chaining ) programming interface enabling much more concise and readable code than standard ADO.NET code is typically written.\r\n\r\nCommon Sequelocity code would be implemented like this:\r\n\r\n```csharp\r\nusing SequelocityDotNet;\r\n\r\npublic static SuperHero GetSuperHero( string superHeroName )\r\n{\r\n\tconst string sqlQuery = @\"\r\nSELECT\tTOP 1 *\r\nFROM\tSuperHero\r\nWHERE\tSuperHeroName = @SuperHeroName\r\n\";\r\n\r\n\tvar superHero = Sequelocity.GetDatabaseCommand()\r\n\t\t.SetCommandText( sqlQuery )\r\n\t\t.AddParameter( \"@SuperHeroName\", superHeroName, DbType.AnsiString )\r\n\t\t.ExecuteToList<SuperHero>()\r\n\t\t.FirstOrDefault();\r\n\t\r\n\treturn superHero;\r\n}\r\n```\r\n\r\nPlease see the project unit tests for many more examples.\r\n\r\n###Basic Concepts###\r\n\r\nSequelocity provides two main paths for easy data access: The DatabaseCommand object and DbCommand extension methods.\r\n\r\n####DatabaseCommand####\r\n\r\nSequelocity introduces one layer of abstraction upon the native .NET framework System.Data.Common.DbCommand in order to introduce several beneficial features such as automatic connection handling, event handlers, and extension points.\r\n\r\n**Automatic Connection Handling**\r\n\r\nWhen utilizing the DatabaseCommand object, all of its execute methods automatically open and close the underlying database connection and dispose of the underlying ADO.NET DbCommand which removes the need for writing the common and repetitive boilerplate code of opening connections, closing connections, and C# using statements.\r\n\r\nThrough experience, we've found that the majority of database code simply needs to issue a single query and return the results so we've optimized the library to handle this most common scenario with ease by handling all connection-related concerns and disposing of no longer needed resources.\r\n\r\nOf course if you are in need to keep a connection open after issuing a command, there are optional parameters that allow you to specify that giving you complete control of the connection handling.\r\n\r\n**Event Handlers aka Interception Points aka Hooks**\r\n\r\nWhen utilizing the DatabaseCommand object, all of its execute methods will automatically invoke / call all registered event handlers before calling the database ( Pre-Invoke ), after the database has been called and the results returned ( Post-Invoke ), and upon any unhandled exceptions.\r\n\r\nIt is very easy to register to one of these events in order to facilitate injecting your own behavior, to assist in debugging, or to enable logging queries, results, or exceptions.\r\n\r\n**Extension Points**\r\n\r\nIf you take a look at the code base for Sequelocity, you will find that almost all of the behavior for the DatabaseCommand object is actually implemented as extension methods. What this means is that new behavior can be easily added by you or your team by simply implementing your own extension methods.\r\n\r\nThis architectural decision was very much intentional and demonstrates that Sequelocity is not really a framework but a utility and helper library for helping you connect and interact with your ADO.NET supported database of choice. The DatabaseCommand object is just a very simple light-weight wrapper around the .NET framework provided DbCommand in order to enable additional functionality and features.\r\n\r\n####DbCommand Extension Methods####\r\n\r\nMost of the code in Sequelocity is actually just extension methods and a large portion of the behavior of the Sequelocity DatabaseCommand object simply forwards calls to the many extension methods we've created for the .NET framework provided DbCommand. This enables an alternative way of using Sequelocity as just a set of fluent extension methods for the native DbCommand object in order to reduce the repetitive boilerplate code typically required to be written when working with raw ADO.NET.\r\n\r\nA majority of the Sequelocity DbCommand extension methods are implemented with the method both taking in the DbCommand as an argument and returning the DbCommand as the result enabling a fluent style syntax creating a more elegant and concise way of writing data access code.\r\n\r\n###Unit Tests and Integration Tests###\r\n\r\nSequelocity is backed by a large test suite comprising over 300 unit and integration tests. These tests serve as a contract specifying the behavior we expect out of each and every method which leads to a lot of tests which appear to be near duplicates of other tests and indeed many of the DatabaseCommand tests are 95% the same code as their DbCommand test counterparts but this is intentional and again is meant to serve as validation of expected method behavior. We hope that such a large test suite will give you confidence and 'the warm and fuzzies' knowing that many, many hours were put into writing tests that cover every inch of code in the Sequelocity code base and it is our hope that this will ensure a low number of bugs, increased quality, and the ability to add new features without breaking existing functionality.\r\n\r\nUnit Test vs Integration Test\r\n- We define unit tests as code that attempts to isolate a single unit, which we typically consider a method, and confirm its expected behavior attempting to not exercise any external resources. \r\n- We define an integration test as basically the same thing as a unit test except the goal is to also exercise the external resources such as running the method against an actual SQLite or Sql Server database. *Note that 'integration test' usually means more than this meaning but for this project this simplified meaning helps to differentiate the two types of testing being performed.\r\n\r\nProject Breakdown:\r\n- SequelocityDotNet - This is the main project and contains only a single file named SequelocityDotNet.cs.\r\n- SequelocityDotNet.Tests - These are unit tests as defined above, are the most abundant, and are lightning fast to run.\r\n- SequelocityDotNet.Tests.SQLite - These are integration tests against an in-memory SQLite database and are lightning fast to run.\r\n- SequelocityDotNet.Tests.SqlServer - These are integration tests against a Sql Server database kindly provided by AppHarbor and take about 8 seconds to run depending on your connection speed. *Note that we do not share the ConnectionString to our test Sql Server for obvious reasons so the tests won't be immediately runnable but you can simply replace the ConnectionString with your own and the tests should run just fine as all tests are self contained and will conveniently create any database objects that they need to satisfy the test.\r\n\r\n###Database Support###\r\n\r\nSequelocity works with all ADO.NET providers including SQL Server, SQLite, SQL CE, Oracle, MySQL, PostgreSQL, Firebird, etc.\r\n\r\n**Database Provider Specific Implementations**\r\n\r\nSequelocity does include a few database provider specific implementation methods listed below. If you would like to contribute additional database provider specific implementations, please feel free to do so by submitting a pull request.\r\n\r\nSQLite\r\n- GenerateInsertForSQLite - Generates a parameterized SQLite INSERT statement from the given object\r\n- GenerateInsertsForSQLite - Generates a list of concatenated parameterized SQLite INSERT statements from the given list of objects\r\n\r\nSQL Server\r\n- GenerateInsertForSqlServer - Generates a parameterized SQLite INSERT statement from the given object\r\n- GenerateInsertsForSqlServer - Generates a list of concatenated parameterized SQLite INSERT statements from the given list of objects\r\n\r\n###Open Source###\r\n\r\nSequelocity is open source software licensed under the MIT License. We love open source and use it extensively in all of our projects so it is with great pleasure that we can contribute back to the developer community with Sequelocity. We encourage you to explore the project, use it to your hearts content, provide feedback, open issue or feature requests, contribute to the project and / or fork it for your own use.\r\n\r\nIf you do find Sequelocity useful, we would love to hear about your experience and add your name to the list of organizations and/or projects that use Sequelocity.\r\n\r\n###License###\r\n\r\nMIT License:\r\n\r\nCopyright (c) 2015 Ambit Energy. All rights reserved.\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and \r\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including \r\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell \r\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the \r\nfollowing conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all copies or substantial \r\nportions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT \r\nLIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN \r\nNO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \r\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. ","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}